# 聊天功能实现说明

## 一、数据库表结构

### 1. `chat_message` 表（聊天消息表）

聊天记录已经存储在 `chat_message` 表中，包含以下字段：

- `id`: 消息ID（主键）
- `session_id`: 会话ID（外键，关联 `chat_session` 表）
- `sender_id`: 发送者ID（外键，关联 `user` 表）
- `receiver_id`: 接收者ID（外键，关联 `user` 表）
- `message_type`: 消息类型（TEXT-文字，IMAGE-图片）
- `content`: 消息内容（文字消息的内容）
- `images`: 图片URL列表（JSON格式，存储多张图片）
- `is_read`: 是否已读（0-未读，1-已读）
- `delete_flag`: 逻辑删除标志（0-未删除，1-已删除）
- `create_time`: 创建时间（消息发送时间）
- `update_time`: 更新时间

### 2. `chat_session` 表（聊天会话表）

- `id`: 会话ID（主键）
- `user1_id`: 用户1 ID
- `user2_id`: 用户2 ID
- `related_type`: 关联类型（LOST_FOUND-失物招领，GOODS-商品，TASK-跑腿任务）
- `related_id`: 关联ID（失物ID、商品ID、任务ID等）
- `last_message_time`: 最后消息时间
- `last_message_content`: 最后消息内容
- `delete_flag`: 逻辑删除标志
- `create_time`: 创建时间
- `update_time`: 更新时间

## 二、消息持久化流程

### 1. 发送消息时保存到数据库

**后端实现**：`ChatSessionServiceImpl.sendMessage()`

```java
// 5. 创建消息并保存到数据库
ChatMessage message = new ChatMessage();
message.setSessionId(dto.getSessionId());
message.setSenderId(senderId);
message.setReceiverId(receiverId);
message.setMessageType(dto.getMessageType());
message.setContent(dto.getContent());
message.setImages(...); // JSON格式存储图片URL
message.setIsRead(0);
message.setDeleteFlag(0);
message.setCreateTime(LocalDateTime.now());
message.setUpdateTime(LocalDateTime.now());

chatMessageMapper.insert(message); // 保存到数据库
```

**关键点**：
- ✅ 消息发送时**立即保存到数据库**
- ✅ 保存后通过 WebSocket 实时推送给接收者
- ✅ 每条消息都有完整的发送者、接收者、时间戳信息

### 2. 加载历史消息

**后端实现**：`ChatSessionServiceImpl.getMessageList()`

```java
public List<ChatMessage> getMessageList(Long sessionId, Long userId) {
    // 1. 验证会话权限
    getSessionDetail(sessionId, userId);
    
    // 2. 查询消息列表（按时间升序，最早的在前）
    LambdaQueryWrapper<ChatMessage> wrapper = new LambdaQueryWrapper<>();
    wrapper.eq(ChatMessage::getSessionId, sessionId)
           .eq(ChatMessage::getDeleteFlag, 0)
           .orderByAsc(ChatMessage::getCreateTime);
    
    List<ChatMessage> messages = chatMessageMapper.selectList(wrapper);
    
    // 3. 标记消息为已读
    chatMessageMapper.markAsRead(sessionId, userId);
    
    return messages;
}
```

**前端实现**：`Chat.vue` 组件

```javascript
// 获取消息列表（打开聊天窗口时调用）
const fetchMessages = async (sessionId) => {
  if (!sessionId) return
  messagesLoading.value = true
  try {
    const response = await chatApi.getMessageList(sessionId)
    if (response.code === 200) {
      messages.value = response.data || [] // 加载历史消息
      // 滚动到底部
      nextTick(() => {
        scrollToBottom()
      })
    }
  } catch (error) {
    ElMessage.error('获取消息列表失败')
  } finally {
    messagesLoading.value = false
  }
}
```

## 三、完整的工作流程

### 场景1：用户A 和用户B 首次聊天

1. **创建会话**：用户A点击"联系TA"，系统创建或获取会话（`chat_session`）
2. **发送消息**：用户A输入消息并发送
   - ✅ 消息保存到 `chat_message` 表
   - ✅ 通过 WebSocket 实时推送给用户B
   - ✅ 更新会话的最后消息时间和内容
3. **接收消息**：用户B实时收到消息（WebSocket推送）
4. **查看历史**：用户B打开聊天窗口时，调用 `getMessageList` 从数据库加载所有历史消息

### 场景2：用户刷新页面后重新打开聊天

1. **加载会话列表**：调用 `getSessionList()` 获取所有会话
2. **选择会话**：用户点击某个会话
3. **加载历史消息**：调用 `getMessageList(sessionId)` 从数据库加载该会话的所有历史消息
4. **实时接收**：WebSocket连接后，新消息会实时推送

### 场景3：多用户聊天

- ✅ 每个会话（`chat_session`）只关联两个用户（`user1_id` 和 `user2_id`）
- ✅ 每个用户可以与多个其他用户创建不同的会话
- ✅ 每个会话的所有消息都存储在 `chat_message` 表中，通过 `session_id` 关联

## 四、消息查询逻辑

### 查询条件

1. **按会话查询**：`WHERE session_id = ? AND delete_flag = 0`
2. **按时间排序**：`ORDER BY create_time ASC`（最早的在前）
3. **权限验证**：只能查看自己参与的会话的消息

### 数据展示

- 消息按时间顺序显示（最早的在上方）
- 区分发送者和接收者（通过 `sender_id` 和 `receiver_id`）
- 显示消息类型（文字/图片）
- 显示发送时间
- 显示已读/未读状态

## 五、已实现的功能

✅ **消息持久化**：所有消息都保存到数据库  
✅ **历史消息加载**：打开聊天窗口时自动加载历史消息  
✅ **实时消息推送**：新消息通过 WebSocket 实时推送  
✅ **多用户支持**：每个用户可以与多个其他用户聊天  
✅ **消息类型**：支持文字和图片消息  
✅ **已读状态**：标记消息已读状态  
✅ **逻辑删除**：支持消息的逻辑删除（不会真正删除数据）

## 六、测试建议

1. **发送消息**：发送几条消息，检查数据库 `chat_message` 表中是否有记录
2. **刷新页面**：刷新后重新打开聊天窗口，检查是否能加载历史消息
3. **多用户测试**：用两个不同的账号互相发送消息，检查是否能正确区分发送者和接收者
4. **时间显示**：检查消息的时间戳是否正确显示

## 七、总结

**聊天记录已经完整实现**：
- ✅ 数据库表 `chat_message` 已创建并包含所有必要字段
- ✅ 消息发送时自动保存到数据库
- ✅ 打开聊天窗口时自动加载历史消息
- ✅ WebSocket 仅用于实时推送新消息，不影响历史记录
- ✅ 刷新页面后历史消息仍然存在并可正常加载

**WebSocket 的作用**：
- 实时推送新消息，提供即时通信体验
- 不影响历史消息的存储和加载

**数据库的作用**：
- 永久存储所有聊天记录
- 支持历史消息查询
- 支持消息的已读状态管理

