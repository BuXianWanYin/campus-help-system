# 校园帮助系统后端开发规范文档

## 一、项目概述

### 1.1 技术栈

#### 后端技术栈
- **框架**：Spring Boot 2.7.18
- **持久层**：MyBatis Plus 3.5.3.1
- **安全认证**：Spring Security + JWT (io.jsonwebtoken 0.11.5)
- **缓存**：Redis (Spring Boot Starter Data Redis)
- **数据库**：MySQL 8.0+
- **连接池**：Druid 1.2.18
- **接口文档**：SpringDoc OpenAPI 1.7.0 (Swagger 3)
- **对象映射**：MapStruct 1.5.5.Final
- **工具类库**：Lombok 1.18.28
- **构建工具**：Maven 3.6+
- **JDK版本**：JDK 1.8
- **其他**：WebSocket、邮件发送 (Spring Mail)

### 1.2 项目架构要求
- 后端采用分层架构，严格遵循MVC模式
- 前后端分离，通过RESTful API进行交互
- 使用SpringDoc OpenAPI实现接口文档自动生成
- 使用JWT进行身份认证和授权
- 使用Redis进行缓存和会话管理

### 1.3 项目基础信息
- **项目包名**：`com.server.campushelpserver`
- **项目名称**：校园帮助系统后端
- **数据库名称**：`campus_help`
- **服务端口**：8080
- **API文档路径**：`/swagger-ui.html`

## 二、项目包结构规范

### 2.1 基础包结构
```
com.server.campushelpserver
├── CampusHelpServerApplication.java  # 启动类
├── common                             # 公共模块
│   ├── Result.java                   # 统一响应结果封装
│   └── ResultCode.java               # 响应码定义
├── config                             # 配置类
│   ├── SecurityConfig                # Spring Security配置
│   ├── RedisConfig                   # Redis配置
│   ├── MybatisPlusConfig             # MyBatis Plus配置
│   ├── OpenApiConfig                 # SpringDoc OpenAPI配置
│   ├── JwtConfig                     # JWT配置
│   ├── JwtAuthenticationFilter       # JWT认证过滤器
│   ├── FileConfig                    # 文件上传配置
│   ├── WebSocketConfig               # WebSocket配置
│   └── AsyncConfig                   # 异步任务配置
├── entity                             # 实体类（Entity层）
│   ├── module1                       # 业务模块1实体
│   │   └── dto                       # 模块1的DTO
│   ├── module2                       # 业务模块2实体
│   │   └── dto                       # 模块2的DTO
│   └── ...                          # 其他业务模块
├── mapper                             # 数据访问层（Mapper层）
│   ├── module1                       # 业务模块1 Mapper
│   ├── module2                       # 业务模块2 Mapper
│   └── ...                          # 其他业务模块
├── service                            # 业务逻辑层接口（Service层）
│   ├── module1                       # 业务模块1 Service接口
│   ├── module2                       # 业务模块2 Service接口
│   └── ...                          # 其他业务模块
├── service.impl                       # 业务逻辑层实现（ServiceImpl层）
│   ├── module1                       # 业务模块1 Service实现
│   ├── module2                       # 业务模块2 Service实现
│   └── ...                          # 其他业务模块
└── controller                         # 控制器层（Controller层）
    ├── module1                       # 业务模块1 Controller
    ├── module2                       # 业务模块2 Controller
    └── ...                          # 其他业务模块
```

### 2.2 包结构设计原则
- **单一职责原则**：每个包只负责一个业务模块
- **分层清晰**：Entity、Mapper、Service、Controller严格分离
- **模块独立**：不同业务模块之间通过接口交互，降低耦合
- **职责明确**：不同功能的控制器分开，便于管理和维护

## 三、Entity层（实体类）规范

### 3.1 实体类命名规范
- 实体类使用大驼峰命名，如：`User`、`Order`、`Product`
- 实体类必须实现`Serializable`接口
- 实体类必须添加`@Data`注解（Lombok）
- 实体类必须添加`@TableName`注解指定表名

### 3.2 实体类字段规范
- 主键字段必须使用`@TableId`注解，类型为`IdType.AUTO`
- 字段必须使用`@TableField`注解指定数据库字段名
- 时间字段使用`LocalDateTime`类型，并添加`@JsonFormat`注解格式化
- 自动填充字段使用`@TableField(fill = FieldFill.INSERT_UPDATE)`注解
- 所有字段必须添加`@Schema`注解用于API文档说明（SpringDoc使用`@Schema`而非`@ApiModelProperty`）
- 字段命名使用小驼峰，数据库字段使用下划线命名
- **敏感字段保护**：密码等敏感字段必须使用`@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)`注解
  - 该注解允许反序列化时接收字段值（如登录时接收密码）
  - 但禁止序列化时返回字段值（防止响应中泄露密码）
  - **禁止使用`@JsonIgnore`**：该注解会同时禁止序列化和反序列化，导致无法接收登录密码等场景

### 3.3 实体类示例规范
```java
package com.server.campushelpserver.entity.user;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;

import java.io.Serializable;
import java.time.LocalDateTime;

/**
 * 用户实体类
 */
@Data
@TableName("user_info")
@Schema(description = "用户实体")
public class User implements Serializable {
    
    private static final long serialVersionUID = 1L;
    
    @TableId(value = "user_id", type = IdType.AUTO)
    @Schema(description = "用户ID")
    private Long userId;
    
    @TableField("username")
    @Schema(description = "用户名", required = true)
    private String username;
    
    @TableField("password")
    @Schema(description = "密码（BCrypt加密）", required = true, hidden = true)
    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
    private String password;
    
    @TableField("create_time")
    @Schema(description = "创建时间")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createTime;
    
    @TableField(value = "update_time", fill = FieldFill.INSERT_UPDATE)
    @Schema(description = "更新时间")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime updateTime;
    
    @TableField("delete_flag")
    @Schema(description = "逻辑删除标志")
    private Integer deleteFlag;
}
```

### 3.4 导入规范
- **必须使用import导入**：所有类必须通过import语句导入，禁止在代码中使用完整类名
- **正确示例**：
  ```java
  import com.baomidou.mybatisplus.annotation.FieldFill;
  
  @TableField(value = "update_time", fill = FieldFill.INSERT_UPDATE)
  ```
- **错误示例**：
  ```java
  // 禁止使用完整类名
  @TableField(value = "update_time", fill = com.baomidou.mybatisplus.annotation.FieldFill.INSERT_UPDATE)
  ```
- **特殊情况**：当类名冲突时，允许使用完整类名，但必须添加注释说明原因

### 3.5 实体类字段类型规范
- **主键类型**：统一使用`Long`类型
- **时间类型**：统一使用`LocalDateTime`
- **布尔类型**：使用`Integer`类型（0/1），配合逻辑删除使用
- **数值类型**：根据业务需求选择`Integer`、`Long`、`BigDecimal`
- **字符串类型**：使用`String`，根据长度限制添加`@TableField`注解

### 3.6 DTO类规范

#### 3.6.1 DTO类位置规范
- **DTO类必须放在对应模块的`entity`包下的`dto`子包中**，如：`entity.user.dto`、`entity.order.dto`
- **禁止**：将DTO类放在`controller`包或`controller`的子包下
- **禁止**：将DTO类放在`common.dto`包下（除非是跨模块的通用DTO）
- DTO类用于特殊情况下的数据传输，如：文件导入、复杂查询参数、特殊验证场景等
- DTO类命名格式：`功能描述 + DTO`，如：`UserImportDTO`、`OrderQueryDTO`

#### 3.6.2 DTO类使用场景
- **文件导入/导出**：Excel导入导出、文件上传等场景
- **复杂查询参数**：多条件组合查询、统计查询等
- **特殊验证场景**：需要特殊字段组合或验证的场景
- **跨模块数据传输**：不同模块间需要传递的数据（此类DTO可放在`common.dto`包下）

#### 3.6.3 DTO类规范要求
- DTO类必须添加`@Schema`注解用于Swagger文档
- 所有字段必须添加`@Schema`注解说明
- 使用Lombok的`@Data`注解简化getter/setter
- DTO类命名必须具有业务含义，清晰表达用途

#### 3.6.4 DTO类位置示例
- **正确示例**：DTO放在对应模块的entity包下
  ```java
  package com.server.campushelpserver.entity.user.dto;
  public class UserImportDTO { ... }
  ```
- **错误示例**：DTO放在controller包下
  ```java
  package com.server.campushelpserver.controller.user.dto;  // ❌ 错误
  public class UserImportDTO { ... }
  ```

## 四、Mapper层规范

### 4.1 Mapper接口规范
- Mapper接口必须继承`BaseMapper<T>`，T为对应的实体类
- Mapper接口命名格式：`实体类名 + Mapper`，如：`UserMapper`、`OrderMapper`
- Mapper接口必须添加`@Mapper`注解或在启动类添加`@MapperScan`（本项目已在`MybatisPlusConfig`中配置`@MapperScan("com.server.campushelpserver.mapper")`）
- 自定义查询方法必须使用`@Select`、`@Update`、`@Insert`、`@Delete`注解
- 复杂查询建议使用XML映射文件，XML文件放在`src/main/resources/mapper`目录下

### 4.4 MyBatis Plus逻辑删除配置
- **必须配置逻辑删除**：在`application-dev.yml`中必须配置MyBatis Plus的逻辑删除功能
- **配置项**：
  ```yaml
  mybatis-plus:
    global-config:
      db-config:
        logic-delete-field: delete_flag  # 逻辑删除字段
        logic-delete-value: 1            # 逻辑删除值（已删除）
        logic-not-delete-value: 0        # 逻辑未删除值（未删除）
  ```
- **自动过滤**：配置后，MyBatis Plus会自动在查询时过滤`delete_flag = 0`的数据
- **自动更新**：调用`removeById()`或`remove()`方法时，会自动将`delete_flag`更新为`1`，而不是物理删除
- **验证配置**：删除操作后必须验证`delete_flag`是否已更新为`1`，确保逻辑删除功能正常工作

### 4.2 Mapper方法命名规范
- 查询方法：`select + 实体名 + By + 条件`，如：`selectUserById`
- 更新方法：`update + 实体名 + By + 条件`
- 删除方法：`delete + 实体名 + By + 条件`
- 插入方法：`insert + 实体名`

### 4.3 Mapper示例规范
```java
package com.server.campushelpserver.mapper.user;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.server.campushelpserver.entity.user.User;
import org.apache.ibatis.annotations.Mapper;

/**
 * 用户Mapper接口
 */
@Mapper
public interface UserMapper extends BaseMapper<User> {
    
    /**
     * 根据用户名查询用户
     * @param username 用户名
     * @return 用户信息
     */
    User selectUserByUsername(String username);
}
```

### 4.4 MyBatis Plus逻辑删除配置（必须配置）

#### 4.4.1 配置要求
- **必须配置逻辑删除**：在`application-dev.yml`中必须配置MyBatis Plus的逻辑删除功能，这是项目的强制要求
- **配置项**（已在项目中配置）：
  ```yaml
  mybatis-plus:
    global-config:
      db-config:
        logic-delete-field: delete_flag  # 逻辑删除字段
        logic-delete-value: 1            # 逻辑删除值（已删除）
        logic-not-delete-value: 0        # 逻辑未删除值（未删除）
  ```
- **配置验证**：启动项目后，MyBatis Plus会自动应用逻辑删除配置，所有查询和删除操作都会自动处理`delete_flag`字段

#### 4.4.2 逻辑删除功能说明
- **自动过滤**：配置后，MyBatis Plus会自动在所有查询语句中添加`WHERE delete_flag = 0`条件，过滤已删除的数据
- **自动更新**：调用`removeById()`、`remove()`、`removeBatchByIds()`等方法时，会自动将`delete_flag`更新为`1`，而不是物理删除
- **物理删除禁止**：配置逻辑删除后，MyBatis Plus的删除方法不会执行物理删除，只会更新`delete_flag`字段

#### 4.4.3 注意事项
- **统一使用**：项目中所有删除操作必须使用MyBatis Plus的逻辑删除方法，禁止手动更新`delete_flag`字段
- **查询已删除数据**：如需查询已删除的数据，必须使用自定义SQL，并在SQL中明确指定`delete_flag = 1`
- **恢复删除**：如需恢复已删除的数据，必须手动调用`updateById()`方法将`delete_flag`更新为`0`

## 五、Service层规范

### 5.1 Service接口规范
- Service接口必须继承`IService<T>`，T为对应的实体类
- Service接口命名格式：`实体类名 + Service`，如：`UserService`、`OrderService`
- Service接口方法必须添加JavaDoc注释，说明方法功能、参数、返回值
- Service接口方法命名使用动词开头，如：`select`、`add`、`update`、`delete`

### 5.2 Service实现类规范
- Service实现类必须继承`ServiceImpl<Mapper, Entity>`并实现对应的Service接口
- Service实现类必须添加`@Service`注解
- Service实现类必须注入对应的Mapper
- Service实现类方法必须添加`@Override`注解
- 业务逻辑复杂的方法必须添加详细注释

### 5.3 Service层职责划分
- **单一职责**：一个Service实现类只负责一个实体类的业务逻辑
- **不可跨模块**：不同业务模块的Service不能互相调用业务方法（可通过Mapper查询基础数据）
- **权限校验**：Service层方法内部必须进行权限校验和数据权限过滤
- **事务管理**：涉及数据修改的方法必须添加`@Transactional`注解

### 5.4 Service方法规范
- 查询方法：返回实体对象或实体列表
- 新增方法：返回操作结果或新增的实体对象
- 更新方法：返回操作结果或更新的实体对象
- 删除方法：返回操作结果（**必须使用MyBatis Plus逻辑删除功能**，详见5.4.3节）
- 所有方法必须进行参数校验和异常处理

#### 5.4.3 删除操作规范（重要，必须遵守）

##### 5.4.3.1 统一使用MyBatis Plus逻辑删除
- **强制要求**：项目中所有删除操作必须统一使用MyBatis Plus的逻辑删除功能，禁止手动更新`delete_flag`字段
- **删除方法**：必须使用MyBatis Plus提供的删除方法：
  - `removeById(id)`：根据ID删除单条记录
  - `removeByIds(ids)`：根据ID批量删除
  - `remove(wrapper)`：根据条件删除
  - `removeBatchByIds(ids)`：批量删除（批量操作）
- **自动处理**：调用上述方法时，MyBatis Plus会自动将`delete_flag`更新为`1`，无需手动设置
- **事务保证**：删除操作必须添加`@Transactional`注解，确保数据一致性
- **返回值处理**：删除方法返回`boolean`类型，`true`表示删除成功，`false`表示删除失败

##### 5.4.3.2 删除操作示例

**正确示例：单条删除**
```java
@Override
@Transactional(rollbackFor = Exception.class)
public boolean deleteUser(Long userId) {
    // 检查数据是否存在（可选，MyBatis Plus会自动处理）
    User user = this.getById(userId);
    if (user == null) {
        throw new BusinessException("用户不存在");
    }
    // 使用MyBatis Plus逻辑删除，自动更新delete_flag为1
    boolean result = this.removeById(userId);
    if (!result) {
        throw new BusinessException("删除失败");
    }
    return true;
}
```

**正确示例：批量删除**
```java
@Override
@Transactional(rollbackFor = Exception.class)
public boolean deleteUsers(List<Long> userIds) {
    if (userIds == null || userIds.isEmpty()) {
        throw new BusinessException("用户ID列表不能为空");
    }
    // 使用MyBatis Plus批量逻辑删除
    boolean result = this.removeByIds(userIds);
    if (!result) {
        throw new BusinessException("批量删除失败");
    }
    return true;
}
```

**正确示例：条件删除**
```java
@Override
@Transactional(rollbackFor = Exception.class)
public boolean deleteUsersByStatus(Integer status) {
    // 构建查询条件
    LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
    wrapper.eq(User::getStatus, status);
    // 使用MyBatis Plus条件删除
    boolean result = this.remove(wrapper);
    if (!result) {
        throw new BusinessException("删除失败");
    }
    return true;
}
```

##### 5.4.3.3 禁止的操作方式

**❌ 错误示例：手动更新delete_flag（禁止）**
```java
// ❌ 禁止：手动更新delete_flag字段
@Override
public boolean deleteUser(Long userId) {
    User user = this.getById(userId);
    user.setDeleteFlag(1);  // ❌ 禁止手动设置
    user.setUpdateTime(LocalDateTime.now());
    return this.updateById(user);  // ❌ 禁止使用updateById更新delete_flag
}
```

**❌ 错误示例：只返回成功不更新数据库（禁止）**
```java
// ❌ 禁止：只返回成功，不更新数据库
@Override
public boolean deleteUser(Long userId) {
    User user = this.getById(userId);
    if (user == null) {
        return false;
    }
    // ❌ 错误：没有实际更新数据库
    return true;
}
```

**❌ 错误示例：使用物理删除（禁止）**
```java
// ❌ 禁止：使用物理删除
@Override
public boolean deleteUser(Long userId) {
    // ❌ 禁止：直接调用Mapper的delete方法进行物理删除
    return baseMapper.deleteById(userId) > 0;
}
```

##### 5.4.3.4 恢复已删除数据
如需恢复已删除的数据，必须手动调用`updateById()`方法：
```java
@Override
@Transactional(rollbackFor = Exception.class)
public boolean restoreUser(Long userId) {
    // 查询已删除的数据（需要自定义SQL，因为MyBatis Plus会自动过滤delete_flag=0）
    User user = baseMapper.selectDeletedUserById(userId);
    if (user == null) {
        throw new BusinessException("用户不存在");
    }
    // 恢复删除：将delete_flag更新为0
    user.setDeleteFlag(0);
    user.setUpdateTime(LocalDateTime.now());
    return this.updateById(user);
}
```

##### 5.4.3.5 查询已删除数据
如需查询已删除的数据，必须在Mapper中自定义SQL：
```java
// Mapper接口
@Select("SELECT * FROM user_info WHERE id = #{id} AND delete_flag = 1")
User selectDeletedUserById(Long id);
```

#### 5.4.1 方法参数规范
- **参数数量限制**：单个方法的参数数量不应超过5个
- **参数过多处理**：当参数超过5个时，必须使用DTO对象封装参数
- **分页查询优化**：分页查询方法如果查询条件超过3个，必须使用QueryDTO封装查询条件
- **操作参数优化**：操作类方法（如审核、筛选等）如果参数超过3个，必须使用DTO对象封装

**示例：参数过多优化**
```java
// ❌ 错误示例：参数过多（9个参数）
Page<User> getUserPage(Page<User> page, String username, String realName, String phone, 
                       Integer status, String roleCodes, Long orgId, Long deptId, Long teamId);

// ✅ 正确示例：使用QueryDTO封装查询条件
Page<User> getUserPage(Page<User> page, UserQueryDTO queryDTO);
```

#### 5.4.2 状态值参数规范
- **禁止硬编码**：方法参数中的状态值、类型值等必须使用枚举类型，禁止使用`Integer`类型
- **枚举优先**：所有状态值、类型值参数应使用对应的枚举类

**示例：状态值参数优化**
```java
// ❌ 错误示例：使用Integer类型的状态值
boolean auditOrder(Long orderId, Integer auditStatus, String auditOpinion);

// ✅ 正确示例：使用枚举类型
boolean auditOrder(Long orderId, AuditStatus auditStatus, String auditOpinion);
```

### 5.5 Service代码质量规范

#### 5.5.1 控制流嵌套规范
- **嵌套层级限制**：方法中的 if/else 嵌套层级不应超过 3 层
- **提取方法**：当嵌套层级超过 3 层时，必须提取为私有方法
- **提前返回**：优先使用提前返回（Early Return）模式，减少嵌套
- **卫语句**：使用卫语句（Guard Clauses）处理异常情况

**示例：避免深层嵌套**
```java
// ❌ 错误示例：嵌套层级过深（4-5层）
public Page<Order> getOrderPage(...) {
    if (condition1) {
        List<Order> orders = ...;
        if (orders != null && !orders.isEmpty()) {
            if (condition2) {
                // 处理逻辑
            } else {
                // 错误处理
            }
        }
    }
}

// ✅ 正确示例：提取方法，减少嵌套
public Page<Order> getOrderPage(...) {
    LambdaQueryWrapper<Order> wrapper = new LambdaQueryWrapper<>();
    applyFilter(wrapper, ...);
    return this.page(page, wrapper);
}

private void applyFilter(LambdaQueryWrapper<Order> wrapper, ...) {
    if (!condition1) return; // 提前返回
    // ... 其他逻辑
}
```

#### 5.5.2 方法长度规范
- **方法长度限制**：单个方法代码行数不应超过 80 行
- **职责单一**：方法应只做一件事，保持职责单一
- **提取方法**：当方法过长时，应提取为多个私有方法

#### 5.5.3 代码可读性规范
- **方法命名**：方法名应清晰表达方法功能
- **注释规范**：复杂业务逻辑必须添加注释说明
- **变量命名**：变量名应具有业务含义，避免使用单字母变量

### 5.6 Service实现类示例规范
```java
package com.server.campushelpserver.service.impl.user;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.server.campushelpserver.entity.user.User;
import com.server.campushelpserver.mapper.user.UserMapper;
import com.server.campushelpserver.service.user.UserService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * 用户Service实现类
 */
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {
    
    @Override
    public Page<User> getUserPage(Page<User> page, UserQueryDTO queryDTO) {
        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
        // 构建查询条件
        if (queryDTO.getUsername() != null) {
            wrapper.like(User::getUsername, queryDTO.getUsername());
        }
        return this.page(page, wrapper);
    }
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public User addUser(User user) {
        // 业务逻辑处理
        this.save(user);
        return user;
    }
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public boolean deleteUser(Long userId) {
        // 使用MyBatis Plus逻辑删除，自动更新delete_flag为1
        // MyBatis Plus会自动处理逻辑删除，无需手动设置delete_flag
        return this.removeById(userId);
    }
}
```

## 六、Controller层规范

### 6.1 Controller类规范
- Controller类必须添加`@RestController`注解
- Controller类必须添加`@RequestMapping`注解指定基础路径
- Controller类必须添加`@Tag`注解（SpringDoc）用于API文档分组
- Controller类命名格式：`功能模块 + Controller`，如：`UserController`、`OrderController`
- Controller必须注入对应的Service接口

### 6.2 Controller方法规范
- 所有方法必须添加`@Operation`注解（SpringDoc）说明接口功能
- 所有方法必须添加权限控制注解（如`@PreAuthorize`）进行权限控制
- 请求参数必须使用`@RequestBody`或`@RequestParam`注解，并添加`@Parameter`注解（SpringDoc）说明参数
- 返回结果必须使用统一的`Result`封装
- 方法命名使用RESTful风格：`get`、`post`、`put`、`delete`
- **使用Entity实体**：Controller层直接使用Entity实体类作为请求和响应对象，不创建额外的DTO类（特殊情况除外，如需要特殊验证或字段组合）
- **DTO使用规范**：如需使用DTO，必须从`entity`包下的`dto`子包导入，禁止在`controller`包下创建DTO类

### 6.3 Controller层职责（重要）
- **禁止在Controller中编写业务逻辑**：所有业务逻辑必须放在Service层
- **Controller只负责**：
  1. 接收HTTP请求参数
  2. 调用Service层方法
  3. 将Service层返回结果封装为`Result`对象返回
  4. 异常处理（通过全局异常处理器统一处理）
- **禁止在Controller中**：
  - ❌ 进行业务判断（如：if判断、数据验证、业务计算等）
  - ❌ 调用多个Service方法组合业务逻辑
  - ❌ 直接操作数据库（调用Mapper）
  - ❌ 构建复杂的数据结构（如：Map、List等业务数据组装）
  - ❌ 文件解析、数据转换等业务操作

### 6.4 Controller职责划分原则
- **严格分离**：不同业务模块必须使用不同的Controller
- **角色分离**：不同角色的操作必须使用不同的Controller
- **不可混用**：一个Controller不能同时处理多个角色的业务逻辑
- **权限隔离**：每个Controller方法必须明确权限要求

### 6.5 RESTful API设计规范
- **GET**：查询操作，如：`GET /api/user/{id}`
- **POST**：新增操作，如：`POST /api/user`
- **PUT**：更新操作，如：`PUT /api/user/{id}`
- **DELETE**：删除操作，如：`DELETE /api/user/{id}`
- **路径命名**：使用小写字母和下划线，如：`/api/user_info`

### 6.6 Controller方法示例规范
```java
package com.server.campushelpserver.controller.user;

import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.server.campushelpserver.common.Result;
import com.server.campushelpserver.entity.user.User;
import com.server.campushelpserver.entity.user.dto.UserQueryDTO;
import com.server.campushelpserver.service.user.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

/**
 * 用户管理控制器
 */
@RestController
@RequestMapping("/api/user")
@Tag(name = "用户管理", description = "用户管理相关接口")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @Operation(summary = "分页查询用户列表", description = "根据条件分页查询用户列表")
    @PreAuthorize("hasAnyRole('ROLE_ADMIN')")
    @GetMapping("/page")
    public Result<Page<User>> getUserPage(
            @Parameter(description = "分页参数") Page<User> page,
            @Parameter(description = "查询条件") @RequestBody UserQueryDTO queryDTO) {
        Page<User> result = userService.getUserPage(page, queryDTO);
        return Result.success("查询成功", result);
    }
    
    @Operation(summary = "新增用户", description = "新增用户信息")
    @PreAuthorize("hasAnyRole('ROLE_ADMIN')")
    @PostMapping
    public Result<User> addUser(@Parameter(description = "用户信息") @RequestBody User user) {
        User result = userService.addUser(user);
        return Result.success("新增成功", result);
    }
}
```

### 6.7 SpringDoc OpenAPI配置规范
- 项目已集成SpringDoc OpenAPI 1.7.0（Swagger 3）
- API文档访问路径：`/swagger-ui.html`
- API文档JSON路径：`/v3/api-docs`
- 所有Controller类必须添加`@Tag`注解，指定分组和描述
- 所有Controller方法必须添加`@Operation`注解，说明接口功能
- 所有请求参数必须添加`@Parameter`或`@Schema`注解，说明参数含义
- 实体类必须添加`@Schema`注解，说明实体类用途
- 注意：SpringDoc使用`@Schema`、`@Tag`、`@Operation`、`@Parameter`注解，而非Swagger 2的`@ApiModel`、`@Api`、`@ApiOperation`、`@ApiParam`注解

## 七、代码注释规范

### 7.1 类注释规范
- 所有类必须添加类注释，说明类的功能和用途
- 类注释只包含类描述，不包含作者和日期信息
- **禁止在注释中使用HTML标签**
- 示例：
  ```java
  /**
   * 统一响应结果封装
   */
  public class Result<T> {
      // ...
  }
  ```

### 7.2 方法注释规范
- 所有public方法必须添加JavaDoc注释
- 方法注释包含：方法描述、参数说明、返回值说明、异常说明
- **禁止在注释中使用HTML标签**
- 示例：
  ```java
  /**
   * 分页查询用户列表
   * @param page 分页参数
   * @param queryDTO 查询条件
   * @return 用户分页列表
   */
  public Page<User> getUserPage(Page<User> page, UserQueryDTO queryDTO) {
      // ...
  }
  ```

### 7.3 字段注释规范
- 实体类字段必须添加`@Schema`注解说明
- 复杂业务字段必须添加行内注释
- 示例：
  ```java
  @Schema(description = "用户名", required = true)
  private String username;  // 用于登录的唯一标识
  ```

## 八、导入语句规范

### 8.1 导入规范要求
- **所有类必须通过import语句导入**：禁止在代码中使用完整类名（如`com.baomidou.mybatisplus.annotation.FieldFill.INSERT_UPDATE`）
- **禁止使用通配符导入**：禁止使用`import xxx.*;`，必须使用显式导入
- **正确示例**：
  ```java
  import com.baomidou.mybatisplus.annotation.FieldFill;
  import com.baomidou.mybatisplus.annotation.TableField;
  
  @TableField(value = "update_time", fill = FieldFill.INSERT_UPDATE)
  ```
- **错误示例**：
  ```java
  // 禁止使用完整类名
  @TableField(value = "update_time", fill = com.baomidou.mybatisplus.annotation.FieldFill.INSERT_UPDATE)
  
  // 禁止使用通配符导入
  import com.baomidou.mybatisplus.annotation.*;
  ```

### 8.2 导入语句组织
- 导入语句按以下顺序组织：
  1. JDK标准库
  2. 第三方库
  3. 项目内部类
- 每组导入之间空一行
- 示例：
  ```java
  import java.io.Serializable;
  import java.time.LocalDateTime;
  
  import com.baomidou.mybatisplus.annotation.IdType;
  import com.baomidou.mybatisplus.annotation.TableId;
  
  import com.server.campushelpserver.common.Result;
  ```

## 九、配置文件规范

### 9.1 application.yml配置
- 主配置文件：`application.yml`
- 开发环境配置：`application-dev.yml`
- 配置项说明：
  - `server.port`: 服务端口（默认8080）
  - `spring.datasource`: 数据库连接配置（使用Druid连接池）
  - `spring.data.redis`: Redis连接配置
  - `mybatis-plus`: MyBatis Plus配置
  - `security.jwt`: JWT配置
  - `file`: 文件上传配置
  - `springdoc`: SpringDoc OpenAPI配置

### 9.2 数据库配置规范
- 使用Druid连接池
- 数据库连接URL格式：`jdbc:mysql://localhost:3306/campus_help?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true`
- 逻辑删除字段：`delete_flag`（0-未删除，1-已删除）

### 9.3 JWT配置规范
- JWT密钥：通过`security.jwt.secret`配置
- Token过期时间：通过`security.jwt.expiration`配置（默认7天）
- Token刷新时间：通过`security.jwt.refresh-expiration`配置（默认30天）
- Token前缀：`Bearer `
- Token请求头：`Authorization`

## 十、代码质量检查规范

### 10.1 方法长度检查
- 单个方法代码行数不应超过 80 行
- 超过限制时，必须提取为多个私有方法

### 10.2 嵌套层级检查
- 方法中的 if/else 嵌套层级不应超过 3 层
- 超过限制时，必须重构代码，使用提前返回或提取方法

### 10.3 参数数量检查
- 单个方法的参数数量不应超过 5 个
- 超过限制时，必须使用DTO对象封装参数

### 10.4 硬编码值检查
- 禁止使用硬编码的魔法数字、字符串等
- 状态值、类型值必须使用枚举类型
- 常量值必须定义在常量类中

### 10.5 未使用代码检查
- 删除所有未使用的导入语句
- 删除所有未使用的枚举类、工具类、常量等
- 使用IDE的自动清理功能

## 十一、安全规范

### 11.1 数据安全
- 敏感数据加密存储（密码使用BCrypt加密）
- SQL注入防护：使用参数化查询（MyBatis Plus自动处理）
- XSS防护：前后端数据校验和转义

### 11.2 接口安全
- 所有接口必须进行身份认证（除登录、注册接口）
- 敏感操作必须进行二次验证
- 接口请求频率限制，防止暴力攻击
- 使用JWT进行身份认证和授权

### 11.3 密码安全
- 密码必须使用BCrypt加密存储
- 密码字段使用`@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)`注解，防止响应中泄露

## 十二、总结

本规范文档涵盖了校园帮助系统后端开发的核心规范，包括：
- 技术栈选择（Spring Boot 2.7.18、MyBatis Plus、Spring Security + JWT等）
- 项目包结构设计（com.server.campushelpserver）
- 各层代码规范（Entity、Mapper、Service、Controller）
- 代码注释规范（禁止HTML标签、作者、日期）
- 导入语句规范
- 代码质量规范（方法长度、嵌套层级等）
- SpringDoc OpenAPI配置规范（Swagger 3）
- 安全规范

开发团队应严格遵守本规范，确保代码质量和项目的可维护性。

